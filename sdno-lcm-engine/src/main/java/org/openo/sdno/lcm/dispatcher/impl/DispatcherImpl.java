/*
 * Copyright 2017 Huawei Technologies Co., Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.openo.sdno.lcm.dispatcher.impl;

import java.util.List;
import java.util.logging.Logger;

import org.openo.sdno.lcm.model.workplan.WorkItem;
import org.openo.sdno.lcm.model.workplan.WorkPlan;
import org.openo.sdno.lcm.model.workplan.WorkPlanExecutionResult;
import org.openo.sdno.lcm.model.workplan.WorkPlanExecutionStrategy;

import org.openo.sdno.lcm.util.SwaggerUtils;
import io.swagger.models.Swagger;
import io.swagger.models.HttpMethod;
import io.swagger.models.parameters.HeaderParameter;
import io.swagger.models.parameters.PathParameter;

import com.fasterxml.jackson.databind.JsonNode;

import org.apache.http.HttpResponse;
import org.openo.sdno.lcm.genericclient.GenericApiClient;
import org.openo.sdno.lcm.exception.ExternalComponentException;

import org.openo.sdno.lcm.dispatcher.Dispatcher;
import org.openo.sdno.lcm.dispatcher.RequestBodyMapper;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class DispatcherImpl implements Dispatcher {
    private final Logger log = Logger.getLogger("DispatcherImpl");

    private RequestBodyMapper requestBodyMapper; //request body mapper
    private GenericApiClient genericApiClient; //generic client to call rest api

    /**
     * Dispatcher executes the work plan generated by Decomposer and returns the execution results
     * Notes:
     * Work plan specifies the order of the tasks to be executed. It also contains all information
     * needed to fulfil each task so that Dispatcher can be independent from other modules.
     *
     * @param plan the work plan generated by Decomposer and to be executed by the Dispatcher
     * @param strategy the strategy followed by the Dispatcher when one work item fails.
     * @return the results of executing the whole plan. It also contains the result for each task.
     */
    @Override
    public WorkPlanExecutionResult dispatch(final WorkPlan plan, final WorkPlanExecutionStrategy strategy) {
        //used to return execution result.
        WorkPlanExecutionResult result = new WorkPlanExecutionResult();
        result.setOverallResult(true);

        //execute work items one by one
        for(int i=0; i<plan.size(); i++) {
            WorkItem item = plan.getWorkItem(i);

            //execute current work item
            boolean success = executeWorkItem(item);
            if(success) { //current work item is executed successfully
                result.addSucceededItem(item);
            } else { //current work item failed
                result.setOverallResult(false);
                result.addFailedItem(item);

                //stop if FAIL_FAST is specified, i.e., return after adding remaining tasks to unprocessed list.
                if(strategy == WorkPlanExecutionStrategy.FAIL_FAST) {
                    for(int j=i+1; j<plan.size(); j++) {
                        result.addUnprocessedItem(plan.getWorkItem(j));
                    }
                    return result;
                }
            }
        }
        return result;
    }


    /**
     * Execute one work item
     * @param workItem the work item to be executed
     * @return whether this work item has been executed successfully. true: success; false: failure
     */
    private boolean executeWorkItem(WorkItem workItem) {
        //get contents from work item
        Swagger swagger = workItem.getSwaggerSpec();
        String apiUrl = workItem.getApiUrl();
        HttpMethod method = workItem.getMethod();

        //generate headers to be sent in HttpRequest
        String contentTypeValue = SwaggerUtils.getConsumeFromSwagger(swagger, apiUrl, method);
        List<HeaderParameter> headers = SwaggerUtils.getHeaderParametersFromSwagger(swagger, apiUrl, method);

        //generate the final url with path parameters
        List<PathParameter> pathParameters = SwaggerUtils.getPathParametersFromSwagger(swagger, apiUrl, method);

        //generate request body if needed
        JsonNode body = requestBodyMapper.map(workItem);

        //invoke API
        try {
            HttpResponse response = genericApiClient.execute(apiUrl, method, 
                                                             contentTypeValue, headers, pathParameters, body);
            //put response message into work item
            workItem.setResponse(response.toString());

            //judge success or not and return;
            return isSuccessful(response);
        } catch(ExternalComponentException e) {
            workItem.setResponse(e.toString());
            return false;
        }
    }

    /**
     * judge whether api call is successful.
     * Note:
     * To be generic, we use only HTTP status code to make the decision.
     * In the future, we may should analyze the response body if APIs are normalized.
     * 
     * @param response HttpResponse from the called service
     * @return whether this call is successful.
     */
    private boolean isSuccessful(HttpResponse response) {
        int statusCode = response.getStatusLine().getStatusCode();
        if((statusCode >=200) && (statusCode<300)) {
            return true;
        } else {
            return false;
        }
    }

    @Autowired
    public void setRequestBodyMapper(RequestBodyMapper requestBodyMapper) {
        this.requestBodyMapper = requestBodyMapper;
    }
    @Autowired
    public void setGenericApiClient(GenericApiClient genericApiClient) {
        this.genericApiClient = genericApiClient;
    }
}